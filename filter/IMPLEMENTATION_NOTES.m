% 实现说明 - 自适应滤波模块
%
% 本文档描述了MEG信号处理的自适应滤波模块实现 (任务 5)。
%
% 已完成子任务:
% ===================
%
% 5.1 LMS算法 (lms_adaptive_filter.m)
% ------------------------------------------
% 实现最小均方自适应滤波算法。
% 
% 主要特性:
% - 独立处理每个MEG通道
% - 使用所有参考通道 (65-67) 作为噪声参考
% - 实现权重更新: W(n+1) = W(n) + mu * e(n) * x(n)
% - 可配置步长 (mu) 和滤波器阶数
% - 返回滤波后的数据、最终权重和误差信号
%
% 需求: 3.1, 3.2
%
%
% 5.2 RLS算法 (rls_adaptive_filter.m)
% ------------------------------------------
% 实现递归最小二乘自适应滤波算法。
%
% 主要特性:
% - 由于时变步长，收敛速度比LMS快
% - 使用卡尔曼增益进行最优权重更新
% - 实现协方差矩阵更新以进行跟踪
% - 遗忘因子lambda按需求限制在 [0.99, 1.0]
% - 返回滤波后的数据、最终权重和误差信号
%
% 需求: 3.1, 3.3
%
%
% 5.3 噪声降低计算 (calculate_noise_reduction.m)
% --------------------------------------------------------------
% 计算滤波后的噪声降低百分比。
%
% 主要特性:
% - 计算滤波前后的信号功率
% - 计算百分比: 100 * (1 - power_after / power_before)
% - 处理边界情况 (零功率、负降低)
% - 返回每个通道的噪声降低指标
%
% 需求: 3.5
%
%
% 算法详情:
% ==================
%
% LMS算法:
% --------------
% 对于每个采样点 n:
%   1. 从延迟的参考通道构造参考向量 x(n)
%   2. 计算滤波器输出: y(n) = W^T * x(n)
%   3. 计算误差: e(n) = d(n) - y(n)
%   4. 更新权重: W(n+1) = W(n) + mu * e(n) * x(n)
%
% 优点: 简单、稳定、计算成本低
% 缺点: 收敛较慢、固定步长
%
%
% RLS算法:
% --------------
% 对于每个采样点 n:
%   1. 构造参考向量 x(n)
%   2. 计算滤波器输出: y(n) = W^T * x(n)
%   3. 计算误差: e(n) = d(n) - y(n)
%   4. 计算卡尔曼增益: k(n) = P * x(n) / (lambda + x^T * P * x)
%   5. 更新权重: W(n) = W(n-1) + k(n) * e(n)
%   6. 更新协方差: P(n) = (P - k * x^T * P) / lambda
%
% 优点: 快速收敛、自适应步长
% 缺点: 计算成本较高、需要矩阵运算
%
%
% 测试:
% ========
%
% 运行 test_adaptive_filters.m 使用合成数据验证实现。
% 测试创建:
% - 17Hz信号 (模拟模体数据)
% - 50Hz和100Hz噪声 (电源线干扰)
% - 参考通道间的相关噪声
%
% 预期结果:
% - 两种算法都应降低噪声功率
% - RLS通常比LMS收敛更快
% - 噪声降低百分比应为正值
%
%
% 使用示例:
% ==============
%
% % 加载MEG数据
% data = load_lvm_data('data.lvm', 4800, 1e-12);
%
% % LMS滤波
% params_lms.mu = 0.01;
% params_lms.filter_order = 10;
% [filtered_lms, weights_lms] = lms_adaptive_filter(...
%     data.meg_channels, data.ref_channels, params_lms);
%
% % RLS滤波
% params_rls.lambda = 0.995;
% params_rls.filter_order = 10;
% [filtered_rls, weights_rls] = rls_adaptive_filter(...
%     data.meg_channels, data.ref_channels, params_rls);
%
% % 计算噪声降低
% [nr_lms] = calculate_noise_reduction(data.meg_channels, filtered_lms);
% [nr_rls] = calculate_noise_reduction(data.meg_channels, filtered_rls);
%
% fprintf('LMS噪声降低: %.2f%%\n', mean(nr_lms));
% fprintf('RLS噪声降低: %.2f%%\n', mean(nr_rls));
%
%
% 参数调整:
% =================
%
% LMS参数:
% - mu (步长): 典型范围 [0.001, 0.1]
%   - 较小的mu: 更稳定、收敛较慢
%   - 较大的mu: 收敛更快、有不稳定风险
%
% - filter_order: 典型范围 [5, 20]
%   - 较小的阶数: 计算更快、噪声降低较少
%   - 较大的阶数: 噪声降低更好、计算较慢
%
% RLS参数:
% - lambda (遗忘因子): 按需求范围 [0.99, 1.0]
%   - lambda = 1.0: 无限记忆 (标准RLS)
%   - lambda < 1.0: 指数遗忘 (对非平稳信号更好)
%
% - delta (初始化): 典型范围 [0.1, 10]
%   - 较小的delta: 初始适应更快
%   - 较大的delta: 初始行为更稳定
%
%
% 性能说明:
% ==================
%
% 计算复杂度:
% - LMS: 每个采样点 O(M)，其中 M = filter_order * n_ref_channels
% - RLS: 由于矩阵运算，每个采样点 O(M^2)
%
% 内存需求:
% - LMS: 权重向量需要 O(M)
% - RLS: 协方差矩阵P需要 O(M^2)
%
% 对于典型参数 (filter_order=10, n_ref_channels=3):
% - LMS: 每个采样点约30次运算
% - RLS: 每个采样点约900次运算
%
% RLS的计算成本约为LMS的30倍，但收敛更快。
%
%
% 验证:
% ===========
%
% 实现已针对以下内容进行验证:
% 1. 具有已知噪声特性的合成数据
% 2. 设计文档中的需求 3.1, 3.2, 3.3, 3.5
% 3. 预期的算法行为 (误差最小化、收敛)
%
% 测试结果显示:
% - 两种算法都成功降低了噪声
% - 输出维度与输入维度匹配
% - 每个通道的权重都正确存储
% - 噪声降低百分比计算正确
%
%
% 后续步骤:
% ===========
%
% 完成本模块后，下一步任务是:
% - 任务 6: 实现频域滤波 (低通、带通、陷波)
% - 任务 7: 实现信号分析 (PSD、SNR计算)
% - 任务 8: 实现触发检测和时程提取
%
% 自适应滤波模块将集成到Mission 1 (模体数据) 和 Mission 2 (人类听觉数据) 
% 的完整处理流程中。
